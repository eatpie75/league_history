// Generated by CoffeeScript 1.3.3
(function() {
  var app, bridge_status_middleware, child_process, client, client_restart, colors, express, http, id, initial, lolclient_middleware, options, path, routes, start_client, status, util, _log;

  child_process = require('child_process');

  colors = require('colors');

  util = require('util');

  express = require('express');

  routes = require('./routes');

  http = require('http');

  path = require('path');

  options = {};

  id = '';

  client = {};

  initial = true;

  status = {
    login_errors: 0,
    total_requests: 0,
    reconnects: 0,
    connected: false
  };

  _log = function(text) {
    return process.send({
      event: 'log',
      server: "" + id,
      text: text
    });
  };

  lolclient_middleware = function(req, res, next) {
    req.lolclient = app.get('lolclient');
    return next();
  };

  bridge_status_middleware = function(req, res, next) {
    req.bridge_status = status;
    return next();
  };

  app = express();

  app.configure(function() {
    app.use(express.logger('dev'));
    app.use(express.bodyParser());
    app.use(express.methodOverride());
    app.use(express.compress());
    return app.use(app.router);
  });

  app.configure('development', function() {
    return app.use(express.errorHandler());
  });

  app.get('/status/', bridge_status_middleware, routes.status);

  app.get('/mass_update/', lolclient_middleware, routes.mass_update);

  app.get('/get_names/', lolclient_middleware, routes.get_names);

  app.get('/search/', lolclient_middleware, routes.search);

  app.get('/spectate/', lolclient_middleware, routes.spectate);

  app.get('/masterybook/', lolclient_middleware, routes.masterybook);

  _log("Preparing to connect".grey);

  start_client = function() {
    if (!initial) {
      options = require('./servers.json')[id];
    }
    client = child_process.fork('client.js');
    client.on('message', function(msg) {
      if (msg.event === 'connected' && initial) {
        initial = false;
        _log("Connected".green);
        status.login_errors = 0;
        status.connected = true;
        app.set('lolclient', client);
        return app.listen(app.settings.port, 'localhost');
      } else if (msg.event === 'connected' && !initial) {
        _log('Reconnected'.green);
        status.login_errors = 0;
        status.connected = true;
        return app.set('lolclient', client);
      } else if (msg.event === 'throttled') {
        return _log("THROTTLED".red);
      } else if (msg.event === 'timeout') {
        return _log("TIMEOUT".red);
      } else if (msg.event === 'log') {
        return _log(msg.text);
      }
    }).on('exit', function(code, signal) {
      var get_time,
        _this = this;
      status.connected = false;
      if (code === 3 || code === 5) {
        console.log(code, signal);
        return setTimeout(client_restart, 2000);
      } else if (code === 1 || code === 4) {
        get_time = function() {
          var _ref, _ref1, _ref2;
          if (status.login_errors * 500 + 1000 <= 6000) {
            _log("restarting client in " + (status.login_errors * 500 + 1000) + "ms");
            return status.login_errors * 500 + 1000;
          } else if ((10 < (_ref = status.login_errors) && _ref < 20)) {
            _log('restarting client in 10s');
            return 10000;
          } else if ((20 <= (_ref1 = status.login_errors) && _ref1 < 30)) {
            _log('restarting client in 1m');
            return 60000;
          } else if ((30 <= (_ref2 = status.login_errors) && _ref2 < 40)) {
            _log('restarting client in 5m');
            return 300000;
          } else if (40 <= status.login_errors) {
            _log('restarting client in 10m');
            return 600000;
          }
        };
        status.login_errors += 1;
        return setTimeout(client_restart, get_time());
      } else {
        return console.log(code, signal);
      }
    });
    return client.send({
      event: 'connect',
      options: options
    });
  };

  client_restart = function() {
    client.removeAllListeners();
    client = null;
    start_client();
    return status.reconnects += 1;
  };

  process.on('message', function(msg) {
    if (msg.event === 'connect') {
      id = msg.id;
      options = msg.options;
      app.set('port', options.listen_port);
      return start_client();
    } else if (msg.event === 'status') {
      return process.send({
        event: 'status',
        data: {
          connected: status.connected,
          total_requests: status.total_requests,
          reconnects: status.reconnects
        },
        server: "" + id
      });
    } else {
      return msg = null;
    }
  });

}).call(this);
