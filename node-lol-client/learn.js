// Generated by CoffeeScript 1.3.3
(function() {
  var RequestHandler, buffer, child_process, client, client_restart, colors, events, h, http, id, initial, json, json2, options, qs, start_client, status, url, util, views, zlib, _log,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  buffer = require('buffer').Buffer;

  child_process = require('child_process');

  colors = require('colors');

  events = require('events');

  http = require('http');

  json = JSON.stringify;

  json2 = JSON;

  qs = require('querystring');

  url = require('url');

  util = require('util');

  zlib = require('zlib');

  views = require('./views');

  options = {};

  id = '';

  status = {
    login_errors: 0,
    total_requests: 0,
    reconnects: 0,
    connected: false
  };

  _log = function(text) {
    return process.send({
      event: 'log',
      server: "" + id,
      text: text
    });
  };

  RequestHandler = (function() {

    function RequestHandler(views, local_client) {
      this.views = views;
      this.send = __bind(this.send, this);

      this.respond = __bind(this.respond, this);

      this.next = __bind(this.next, this);

      this.request = __bind(this.request, this);

      this.client = local_client;
      this.connections = 0;
      this.current = 0;
      this.queue = [];
    }

    RequestHandler.prototype.request = function(request, response) {
      var path, view, _ref;
      path = url.parse(request.url);
      if (_ref = path.pathname, __indexOf.call(Object.keys(this.views), _ref) >= 0) {
        if (this.connections === 0) {
          this.connections += 1;
          view = new this.views[path.pathname](path.query, this.client, this.respond, request, response);
          view.go();
        } else {
          this.queue.push({
            path: path,
            request: request,
            response: response
          });
        }
      } else if (path.pathname === '/status/') {
        response.writeHead(200);
        response.write(json({
          connected: status.connected,
          connections: h.connections,
          total_requests: status.total_requests,
          reconnects: status.reconnects
        }));
        response.end();
      } else {
        _log(("" + path.pathname).cyan + " >> Status:" + "404".red);
        response.writeHead(404);
        response.write('404');
        response.end();
      }
      return this.queue.length;
    };

    RequestHandler.prototype.next = function() {
      var view;
      if (this.current === 0) {
        this.current = this.queue.shift();
      } else {
        console.log('###########');
        console.log(this.current);
        console.log('###########');
        console.log(this);
        console.log('###########');
      }
      this.connections += 1;
      view = new this.views[this.current.path.pathname](this.current.path.query, this.client, this.respond, this.current.request, this.current.response);
      return view.go();
    };

    RequestHandler.prototype.respond = function(data, request, response) {
      var body, mimetype, obj,
        _this = this;
      status.total_requests += data.requests;
      if (!(data.html != null)) {
        body = json(data.body);
        mimetype = 'application/json';
      } else {
        body = data.body;
        mimetype = 'text/html';
      }
      obj = {
        'status': data.status,
        'body': body,
        'headers': {
          'Content-Type': '#{mimetype}; charset=UTF-8'
        },
        'path': url.parse(request.url).pathname
      };
      if (request.headers['accept-encoding'].toLowerCase().indexOf('gzip') !== -1) {
        obj['headers']['Content-Encoding'] = 'gzip';
        return zlib.gzip(obj['body'], function(e, r) {
          return _this.send(response, obj, {
            'body': r
          });
        });
      } else {
        return this.send(response, obj);
      }
    };

    RequestHandler.prototype.send = function(response, data, args) {
      var content_length, k, v;
      if (args != null) {
        for (k in args) {
          v = args[k];
          data[k] = v;
        }
      }
      content_length = new buffer(data['body']).length;
      data['headers']['Content-Length'] = content_length;
      response.writeHead(data.status, data.headers);
      response.write(data.body);
      response.end();
      this.connections -= 1;
      this.current = 0;
      if (this.queue.length > 0) {
        this.next();
      }
      return _log(("" + data.path).cyan + " >> Status:" + ("" + data.status).green + " >> Length:" + ("" + content_length).magenta);
    };

    return RequestHandler;

  })();

  _log("Preparing to connect".grey);

  client = {};

  initial = true;

  h = {};

  start_client = function() {
    if (!initial) {
      options = require('./servers.json')[id];
    }
    client = child_process.fork('client.js');
    client.on('message', function(msg) {
      var server;
      if (msg.event === 'connected' && initial) {
        initial = false;
        _log("Connected".green);
        status.login_errors = 0;
        status.connected = true;
        h = new RequestHandler(views, client);
        server = http.createServer(h.request);
        return server.listen(options.listen_port || 8081, 'localhost');
      } else if (msg.event === 'connected' && !initial) {
        _log('Reconnected'.green);
        status.login_errors = 0;
        status.connected = true;
        h.client = client;
        return h.connections = 0;
      } else if (msg.event === 'throttled') {
        return _log("THROTTLED".red);
      } else if (msg.event === 'timeout') {
        return _log("TIMEOUT".red);
      } else if (msg.event === 'log') {
        return _log(msg.text);
      }
    }).on('exit', function(code, signal) {
      var get_time,
        _this = this;
      status.connected = false;
      if (code === 3 || code === 5) {
        console.log(code, signal);
        console.log(h.current);
        console.log(h.queue);
        console.log(h.connections);
        return setTimeout(client_restart, 2000);
      } else if (code === 1 || code === 4) {
        get_time = function() {
          var _ref, _ref1, _ref2;
          if (status.login_errors * 500 + 1000 <= 6000) {
            _log("restarting client in " + (status.login_errors * 500 + 1000) + "ms");
            return status.login_errors * 500 + 1000;
          } else if ((10 < (_ref = status.login_errors) && _ref < 20)) {
            _log('restarting client in 10s');
            return 10000;
          } else if ((20 <= (_ref1 = status.login_errors) && _ref1 < 30)) {
            _log('restarting client in 1m');
            return 60000;
          } else if ((30 <= (_ref2 = status.login_errors) && _ref2 < 40)) {
            _log('restarting client in 5m');
            return 300000;
          } else if (40 <= status.login_errors) {
            _log('restarting client in 10m');
            return 600000;
          }
        };
        status.login_errors += 1;
        return setTimeout(client_restart, get_time());
      } else {
        return console.log(code, signal);
      }
    });
    return client.send({
      event: 'connect',
      options: options
    });
  };

  client_restart = function() {
    client.removeAllListeners();
    start_client();
    return status.reconnects += 1;
  };

  process.on('message', function(msg) {
    if (msg.event === 'connect') {
      id = msg.id;
      options = msg.options;
      return start_client();
    } else if (msg.event === 'status') {
      return process.send({
        event: 'status',
        data: {
          connected: status.connected,
          connections: h.connections,
          total_requests: status.total_requests,
          reconnects: status.reconnects
        },
        server: "" + id
      });
    }
  });

}).call(this);
