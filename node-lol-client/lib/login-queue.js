// Generated by CoffeeScript 1.3.3
(function() {
  var http, https, performQueueRequest, u,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  u = require('underscore');

  http = require('http');

  https = require('https');

  performQueueRequest = (function() {

    function performQueueRequest(host, username, password, cb) {
      this.host = host;
      this.username = username;
      this.password = password;
      this.cb = cb;
      this._request = __bind(this._request, this);

      this._attempt_login = __bind(this._attempt_login, this);

      this._get_ip = __bind(this._get_ip, this);

      this._get_token = __bind(this._get_token, this);

      this._check_queue = __bind(this._check_queue, this);

      this._next_check = __bind(this._next_check, this);

      this.options = {
        host: host,
        port: 443,
        method: 'POST'
      };
      this._attempt_login();
    }

    performQueueRequest.prototype._next_check = function() {
      var delay, diff, remaining;
      remaining = Math.round((this.target - this.current) / this.queue_rate);
      console.log("" + this.username + " in queue, postition:" + this.current + "/" + this.target + ", " + (Math.floor(remaining / 60)) + ":" + (Math.round(remaining % 60)) + " remaining");
      diff = this.target - this.current;
      if (diff < 100) {
        delay = 7000;
      } else if (diff < 1000) {
        delay = 10000;
      } else if (diff < 10000) {
        delay = 30000;
      } else {
        delay = 180000;
      }
      return setTimeout(this._check_queue, delay);
    };

    performQueueRequest.prototype._check_queue = function() {
      var args,
        _this = this;
      args = {
        path: "/login-queue/rest/queue/ticker/" + this.queue_name
      };
      return this._request(args, null, function(err, res) {
        var key;
        key = u.find(u.keys(res), function(tmp) {
          if (Number(tmp) === _this.queue_node) {
            return true;
          } else {
            return false;
          }
        });
        _this.current = parseInt("0x" + res[key]);
        if (_this.current >= _this.target) {
          return _this._get_token();
        } else {
          return _this._next_check();
        }
      });
    };

    performQueueRequest.prototype._get_token = function() {
      var args,
        _this = this;
      args = {
        path: "/login-queue/rest/queue/authToken/" + this.user
      };
      console.log("" + this.username + " getting token");
      return this._request(args, null, function(err, res) {
        if (res.token != null) {
          return _this._get_ip(function(ip) {
            res.ip_address = ip;
            return _this.cb(null, res);
          });
        } else {
          return _this._next_check();
        }
      });
    };

    performQueueRequest.prototype._get_ip = function(cb) {
      var args,
        _this = this;
      args = {
        path: '/services/connection_info',
        host: 'll.leagueoflegends.com',
        port: 80
      };
      return this._request(args, null, function(err, res) {
        return cb(res.ip_address);
      });
    };

    performQueueRequest.prototype._attempt_login = function() {
      var args, data,
        _this = this;
      args = {
        path: '/login-queue/rest/queue/authenticate'
      };
      data = "payload=user%3D" + this.username + "%2Cpassword%3D" + this.password;
      return this._request(args, data, function(err, res) {
        var tmp;
        if (res.status === 'LOGIN') {
          return _this.cb(null, res);
        } else if (res.status === 'QUEUE') {
          _this.user = res.user;
          _this.queue_name = res.champ;
          _this.queue_node = res.node;
          _this.queue_rate = res.rate + 0.0;
          tmp = u.find(res.tickers, function(ticker) {
            if (ticker.node === _this.queue_node) {
              return true;
            } else {
              return false;
            }
          });
          _this.target = tmp.id;
          _this.current = tmp.current;
          return _this._next_check();
        }
      });
    };

    performQueueRequest.prototype._request = function(kwargs, payload, cb) {
      var agent, options, req;
      options = u.clone(this.options);
      if (kwargs != null) {
        u.extend(options, kwargs);
      }
      if (!(payload != null)) {
        options.method = 'GET';
      }
      if (options.port === 443) {
        agent = https;
      } else {
        agent = http;
      }
      req = agent.request(options, function(res) {
        return res.on('data', function(d) {
          var data;
          data = JSON.parse(d.toString('utf-8'));
          return cb(null, data);
        });
      });
      req.on('error', function(err) {
        console.log(err);
        req.abort();
        return process.exit(1);
      }).on('socket', function(socket) {
        socket.setTimeout(20000);
        return socket.on('timeout', function() {
          console.log('things are about to go poorly');
          req.abort();
          return process.exit(1);
        });
      });
      if (payload != null) {
        return req.end(payload);
      } else {
        return req.end();
      }
    };

    return performQueueRequest;

  })();

  module.exports = performQueueRequest;

}).call(this);
